import java.util.Random;


public class automataLib {

	Universe u;
	Random r = new Random();
	dataSources d;
	
	neighbours n; //TEST
	
	public automataLib(Universe uni, dataSources data) {
		u=uni;
		d=data;
		
		
		int nbrCount = r.nextInt(9)+1; //settings for neighbours if the function does not define them
		int rr = 8; //random roll
		int rrr = 4; //minus rrr to allow rolls to be negatives
		
		n = new neighbours(nbrCount);
		
		for(int ni = 0; ni < nbrCount; ni++) {
			n.setNBH(r.nextInt(rr)-rrr, r.nextInt(rr)-rrr, 0, ni);
		}

		
	}
	
	public void test(int xx, int yy, int zz){					//TEST
		
		
		
	}
	

	public void explore2(int xx, int yy, int zz){					//TEST
		n = new neighbours(4);
		n.setNBH(-7, 0, 0, 0);
		n.setNBH(0, -7, 0, 1);
		n.setNBH(7, 0, 0, 2);
		n.setNBH(0, 7, 0, 3);
		
		if(getval(xx,yy,zz) <= 0) {
			for(int i = 0; i < n.NBH.length; i++) {
				if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {
					
					u.universe[xx][yy][zz]++;
					u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]--;
				}
			}
		}
	}

	
	public void explorer(int xx, int yy, int zz){

		n = new neighbours(4);
		n.setNBH(-1, 0, 0, 0);
		n.setNBH(0, -1, 0, 1);
		n.setNBH(1, 0, 0, 2);
		n.setNBH(0, 1, 0, 3);
		
		if(getval(xx,yy,zz) <= 0) {
			for(int i = 0; i < n.NBH.length; i++) {
				if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {
					
					u.universe[xx][yy][zz]++;
					u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]--;
				}
			}
		}
		
		/*if(i > 0) {if(i < mySize-1) {if(j > 0) {if(j < mySize-1) { 
			if((pointsArray[i][j] < 1 )){   
				if((pointsArray[i+1][j] <= 0 ) || ( pointsArray[i-1][j]<= 0 ) || ( pointsArray[i][j+1]<= 0 && pointsArray[i][j-1]<= 0 )){   
					if((pointsArray[i+1][j] > 0 )) { pointsArray[i][j]  = 1; pointsArray[i+1][j] -= 1;  } 
					if(( pointsArray[i-1][j]> 0 )) { pointsArray[i][j]  = 1; pointsArray[i-1][j] -= 1;  } 
					if(( pointsArray[i][j+1]> 0 )) { pointsArray[i][j]  = 1; pointsArray[i][j+1] -= 1;  } 
					if(( pointsArray[i][j-1]> 0 )) { pointsArray[i][j]  = 1; pointsArray[i][j-1] -= 1;  }
					}}
			}}}}  
		}*/
    }
	
	
	public boolean ifval(int xx, int yy, int zz, int val){ //checks if a cell is a value
		
		if(u.snapshotUniverse[xx][yy][zz] == val) {
			return true;
		} else { 
			return false;
		}
		
	}
	
	public int getval(int xx, int yy, int zz){ //returns cell value
		return u.snapshotUniverse[xx][yy][zz];
	}
	
	
	
	public void writeData(int[] dd) {
		for(int i = 0; i < u.universe.length; i++) {
			for (int j = 0; j < u.universe[0].length; j++) {
				for (int k = 0; k < u.universe[0][0].length; k++) {
					u.universe[i][j][k] = d.readNext(dd);
				}
			}
    	}
	}
	
    public int getWrap(int val, int mod, int len) { //takes array co-ord, modification int, array param length, and returns wrap position.

    	//it is possible that this code is slightly misaligned. Noticed deaths occuring when passing from bottom to top
    	
    	if((val+mod) % len < 0) {return len+((val+mod) % len);} else {return (val+mod) % len;}
    	
    }
	
    public void changeNBHTEST(int rand){
    	if (r.nextInt(rand) == 0) {
    		n.setNBH(r.nextInt(32)-16, r.nextInt(32)-16, 0, 0);
    	}
    }
    
	
	public void rain(int xx, int yy, int zz){//TEST
		
		n = new neighbours(3);
		n.setNBH(-1, -1, 0, 0);
		n.setNBH(1, -1, 0, 1);
		n.setNBH(0, -1, 0, 2);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
		}
		

		
		if(isOne == 1) {
			u.universe[xx][yy][zz] = 0;
		}// else {u.universe[xx][yy][zz] = 0;}

		if(isOne == 2) {
			u.universe[xx][yy][zz] = 1;
		}


    }
	
public void rain2(int xx, int yy, int zz){//TEST
		
		n = new neighbours(5);
		n.setNBH(-1, -1, 0, 0);
		n.setNBH(1, -1, 0, 1);
		n.setNBH(0, -1, 0, 2);
		n.setNBH(-1, 0, 0, 3);
		n.setNBH(1, 0, 0, 4);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
		}
		

		
		if(isOne != 2) {
			u.universe[xx][yy][zz] = 0;
		}// else {u.universe[xx][yy][zz] = 0;}

		if(isOne == 2) {
			u.universe[xx][yy][zz] = 1;
		}


    }
	
	public void sierpenski(int xx, int yy, int zz){// makes a sierpenski triangle lattice that appears to 'count' linearly
		n = new neighbours(2);
		n.setNBH(-1, -1, 0, 0);
		n.setNBH(1, -1, 0, 1);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
			// IF u.universe, NOT u.snapshot. Weird.
			//if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
			
		}
		
		if(isOne == 1) {
			u.universe[xx][yy][zz] = 1;
		} else {u.universe[xx][yy][zz] = 0;}

    }
	
	public void conway(int xx, int yy, int zz){ //demonstration of conway's game of life
		
		n = new neighbours(8);
		n.setNBH(-1, -1, 0, 0);
		n.setNBH( 0, -1, 0, 1);	
		n.setNBH( 1, -1, 0, 2);
		n.setNBH(-1, 0, 0, 3);	
		n.setNBH( 1, 0, 0, 4);
		n.setNBH(-1, 1, 0, 5);	
		n.setNBH(0, 1, 0, 6);
		n.setNBH(1, 1, 0, 7);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
		}
		
		if(isOne < 2)  { u.universe[xx][yy][zz] = 0; }
		if(isOne > 3)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 3) { u.universe[xx][yy][zz] = 1; }

    }
	
	public void pissRandomly(int xx, int yy, int zz, int halfRand, int freq) { //chance to reset to random +/- halfrand

		if(r.nextInt(freq) == 0) {
			u.universe[xx][yy][zz] = r.nextInt(halfRand*2)-(halfRand);
			if(u.snapshotUniverse[xx][yy][zz] > u.maxVal) {u.maxVal = u.universe[xx][yy][zz];}
		}

    }
	
	public void pissPositive(int xx, int yy, int zz, int rand, int freq) { //chance to reset to something random, but positive

		if(r.nextInt(freq) == 0) {
			u.universe[xx][yy][zz] = r.nextInt(rand);
			if(u.snapshotUniverse[xx][yy][zz] > u.maxVal) {u.maxVal = u.universe[xx][yy][zz];}
		}

    }
    
    public void placeOne(int xx, int yy, int zz) { //set to 1
    	u.universe[xx][yy][zz] = 1;
    }
    
    public void placeval(int xx, int yy, int zz, int v) { //set to 1
    	u.universe[xx][yy][zz] = v;
    }
    
    public void placeO(int xx, int yy, int zz) { //set to 1
    	u.universe[xx][yy][zz] = 0;
    }
	
    public void transcribeBinaryData(int xx, int yy, int zz, boolean showO) {
    	if(!showO){	if(d.readNext(d.sources[0]) == 1) {u.universe[xx][yy][zz] = 1;} } else {
    		u.universe[xx][yy][zz] = d.readNext(d.sources[0]);
    	}
    }
    
    public void placeLine(int xx, int yy, int zz, int rand, int len, boolean placeO, boolean horiz, int veto) { //draws a line with chance. Doesn't support z
    	
    	if(r.nextInt(veto) == 0) {
	    	if(horiz) {
		    	for(int i = 0; i < len-xx; i++) {
		    		if(r.nextInt(rand) == 0) {
		    			placeOne(xx+i, yy, zz);
		    		} else if(placeO) {placeO(xx+i, yy, zz);}
		    	}
		    } else {
		    	for(int i = 0; i < len-yy; i++) {
		    		if(r.nextInt(rand) == 0) {
		    			placeOne(xx, yy+i, zz);
		    		} else if(placeO) {placeO(xx, yy+i, zz);}
		    	}
	    	}
    	}
    }
    
public void placeLineO(int xx, int yy, int zz, int rand, int len, boolean placeO, boolean horiz, int veto) { //draws a line with chance. Doesn't support z
    	
    	if(r.nextInt(veto) == 0) {
	    	if(horiz) {
		    	for(int i = 0; i < len-xx; i++) {
		    		if(r.nextInt(rand) == 0) {
		    			placeO(xx+i, yy, zz);
		    		} else if(placeO) {placeOne(xx+i, yy, zz);}
		    	}
		    } else {
		    	for(int i = 0; i < len-yy; i++) {
		    		if(r.nextInt(rand) == 0) {
		    			placeO(xx, yy+i, zz);
		    		} else if(placeO) {placeOne(xx, yy+i, zz);}
		    	}
	    	}
    	}
    }
    
    public void seed(int xx, int yy, int zz, int rand){ //chance to seed location
    	if(r.nextInt(rand) == 0) {placeOne(xx, yy, zz);}
    }
    
    public void startSierpenski(int xx, int yy) {
    	seed(xx, yy, 0, 1);
    	seed(xx+2, yy, 0, 1);
    }
    
    public void seedAll(int rand){ //chance to seed every pixel
    	for(int i = 0; i < u.universe.length; i++) {
			for (int j = 0; j < u.universe[0].length; j++) {
				for (int k = 0; k < u.universe[0][0].length; k++) {
			    	seed(i,j,k,rand);
				}
			}
    	}
    }
    
    public void seedZ(int rand, int zz){ //chance to seed every pixel
    	for(int i = 0; i < u.universe.length; i++) {
			for (int j = 0; j < u.universe[0].length; j++) {
			    seed(i,j,zz,rand);
			}
    	}
    }
    
}
