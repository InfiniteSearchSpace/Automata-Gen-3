

import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;
import java.util.Random;

import javax.swing.JLabel;
import javax.swing.JPanel;


@SuppressWarnings("serial")
public class ml extends JPanel implements MouseListener {

	//create containers for reference objects
	Main m;
	Surf[] s;
	JLabel l;
	Point p;
	Point p2;
	Universe u[];
	
	int sfcnum = 0;			//index of current active/interactable surface
	int sfcmax;				//total number of surfaces to cycle through
	int myFunction = 1;  	//reference for current mouse function on click
	int functionType = 0;	//Determines subclass of functions to execute, like a menu.
	
	int fcnt = 5;			//total number of mouse functions to iterate through
	int fnctype = 5;		//tot number of function catagorys
	
	//constructor
    public ml(Main mm, Surf[] ss, JLabel ll, Universe uni[]) {
    	//System.out.println("ml");
    	m=mm;
    	s=ss;
    	l=ll;
    	u=uni;
    	
        m.addMouseListener(this);
        
        sfcmax=s.length;
        functionType = 0;
    }
    
    //do I need this?
    void eventOutput(String eventDescription, MouseEvent e) {
        System.out.println(eventDescription + " detected on "
                + e.getComponent().getClass().getName()
                + ".");
    }
    
    public void mousePressed(MouseEvent e) {
    	
    	//get location information from mouse & jframes
    	p = MouseInfo.getPointerInfo().getLocation();
    	p2 = m.getLocation();
    	int mx =(p.x - p2.x - 2 - s[sfcnum].getX());
    	int my =(p.y - p2.y - 24 - s[sfcnum].getY());
    	
    	//Left Click
    	 if(e.getButton() == MouseEvent.BUTTON1) {
    	
	    	//When subfunction 0 is active, always scroll through z/depth of this surface
	    	if (myFunction == 0) {  
				s[sfcnum].zdraw++;
				s[sfcnum].zdraw = s[sfcnum].zdraw % s[sfcnum].zz;
			}
	    	
	    	
	    	//Function type/catagory 0's options
	    	if(functionType == 0) {
	    		if (myFunction ==  1) { //Place One
	        		s[sfcnum].u.a.seed(mx, my, s[sfcnum].zdraw, 1, 0, 1);
	        	}
	    		
	    		if (myFunction ==  2) { //Place Block Small
	    	    	int num = 3;
	    			for(int i = 0; i < num*2; i++){
	    				s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 1, mx+num, false, 1, 1);
	    			}
	        	}
	    		
	    		if (myFunction ==  3) { //Place block medium 
	    	    	int num = 8;
	    			for(int i = 0; i < num*2; i++){
	    				s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 1, mx+num, false, 1, 1);
	    			}
	        	}
	    		
	    		if (myFunction ==  4) { //Place Block Big
	    	    	int num = 14;
	    			for(int i = 0; i < num*2; i++){
	    				s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 1, mx+num, false, 1, 1);
	    			}
	        	}
	    	}
	
	    	//Function type/catagory 1's options
	    	if(functionType == 1) {
	    		if (myFunction ==  1) { //chance block random Light			
	    			int num = 16;
	    			for(int i = 0; i < num*2; i++){
	    	    		s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 64, mx+num, false,1, 1);
	    	    	}
	    		}
	    		
	    		if (myFunction ==  2) { //chance block random Heavy
	    			int num = 16;
	    			for(int i = 0; i < num*2; i++){
	    	    		s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 3, mx+num, false, 1, 1);
	    	    	}
	    		}
	    		
	    		if (myFunction ==  3) { //Place Big Block Horizontal 3-step Stripes
	    	    	int num = 24;
	    			for(int i = 0; i < num*2; i+=3){
	    				s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 1, mx+num, false, 1, 1);
	    			}
	        	}
	    		
	    		if (myFunction ==  4) { //Place medium Block 2-step Stripes
	    	    	int num = 10;
	    			for(int i = 0; i < num*2; i+=2){
	    				s[sfcnum].u.a.placeLine(mx-num, (my+i)-num, s[sfcnum].zdraw, 1, mx+num, false, 1, 1);
	    			}
	        	}
	    	}
	    	
	    	//Function type/catagory 2's options
	    	if(functionType == 2) {
	    		if (myFunction == 1) { //Set to 0, one
	    			s[sfcnum].u.a.placeval(mx, my, s[sfcnum].zdraw, 1, 0